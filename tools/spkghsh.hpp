//   InteLib                                    http://www.intelib.org
//   The file tools/spkghsh.hpp
// 
//   Copyright (c) Andrey Vikt. Stolyarov, 2000-2009
// 
// 
//   This is free software, licensed under GNU LGPL v.2.1
//   See the file COPYING for further details.
// 
//   THERE IS NO WARRANTY OF ANY KIND, EXPRESSED, IMPLIED OR WHATEVER!
//   Please see the file WARRANTY for the detailed explanation.




/*! \file spkghsh.hpp
    \brief Hashtable-based package of symbols

    A package (that is, a relation between names and corresponding
    objects) based on a hash table.  See the SExpressionHashPackage
    class description for details.
 */

#ifndef INTELIB_SPKGHSH_HPP_SENTRY
#define INTELIB_SPKGHSH_HPP_SENTRY

#include "../sexpress/iexcept.hpp"
#include "../sexpress/sexpress.hpp"
#include "../sexpress/gensref.hpp"
#include "../sexpress/shashtbl.hpp"
#include "sreader.hpp"

class SExpressionHashPackage;

//! Exception: package expected
class IntelibX_not_a_package : public IntelibX {
public:
    IntelibX_not_a_package(SReference a_param);
};

//! Reference to a SExpressionHashPackage
typedef GenericSReference<SExpressionHashPackage, IntelibX_not_a_package> 
SHashPackage;


//! Hashtable-based package
/*! 
  SExpressionHashPackage is used to translate strings to label objects.  
  Labels generated by the package are stored inside the package. 
  Note there can be labels registered but not stored in the 
  package, in which case we assume they are stored somewhere else,
  e.g. defined as a named (non-dynamic) variable.
*/
class SExpressionHashPackage : public SExpressionHashTable,
                               public IntelibPackage
{
    SHashPackage parent; //!< Parent package, if any
public:
        //! The type identifier
    static IntelibTypeId TypeId;

        //! The default constructor (empty package)
    SExpressionHashPackage();
        //! Construct a package on top of another package
    SExpressionHashPackage(const SHashPackage& a_parent);
protected:
    ~SExpressionHashPackage();
    SExpressionHashPackage(const IntelibTypeId& tid);
    SExpressionHashPackage(const IntelibTypeId& tid,
                           const SHashPackage& a_parent);

public:
        
        //! Register an existing symbol with the package.
        /*! Similar to CL's function IMPORT. Return false on a name 
            conflict, true on success.
            \param symb is the symbol to register
            \param symbname If given, the parameter determines the name
            by which the symbol will be known in this package. Default 
            is to get symbname from the symbol.
            \param safe If true (the default), the function avoids name 
            conflicts. If false, the symbol is imported even if another
            symbol is already known by that name; in this case, the 
            function always returns true.
         */
    bool Import(const SReference &symb, const char *symbname = 0, 
                bool safe = true);

        //! Provide a symbol with the given name. 
        /*! If no symbol found, create it. Similar to CL's Intern. */
    SReference Intern(const char *name); 

        //! Find a symbol. Return reference to it. 
        /*! If nothing found, return NO-VALUE (unbound reference). */
    SReference FindSymbol(const char *name);

private:
        /*! reimplemented from IntelibPackage */
    virtual SReference MakeSymbol(const char *name);
 
protected:
        //! This is how new symbol objects are created
        /*! This function is called by Intern() in case new object
            is to be created.  For this class, it simply creates
            an SExpressionLabel object, but children can override
            it so that symbols of a particular type are created.
         */
    virtual SReference CreateNewSymbolObject(const char *name) const;

#if INTELIB_TEXT_REPRESENTATIONS == 1
    virtual SString TextRepresentation() const;
#endif
};

//! Exception: name conflict within a package
class IntelibX_package_conflict : public IntelibX {
public:
    IntelibX_package_conflict(SReference a_param);
};

#endif        // sentry
